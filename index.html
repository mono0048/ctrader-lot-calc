<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>ALC v3.0 (Fixed)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <style>
        body {
            background: #121212;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            padding: 20px;
            margin: 0;
        }

        h1 {
            font-size: 20px;
            margin: 0 0 15px 0;
            color: #64b5f6;
            font-weight: 600;
        }

        .card {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .label {
            font-size: 11px;
            color: #9e9e9e;
            margin-bottom: 4px;
            display: block;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .value {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }

        .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .row:last-child {
            margin-bottom: 0;
        }

        input,
        select,
        button {
            width: 100%;
            box-sizing: border-box;
            padding: 12px;
            background: #2c2c2c;
            border: 1px solid #424242;
            color: #fff;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
            transition: 0.2s;
        }

        input:focus,
        select:focus {
            border-color: #64b5f6;
            background: #333;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            background: #1976d2;
            border: none;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 14px;
            letter-spacing: 0.5px;
        }

        button:active {
            transform: translateY(1px);
            background: #1565c0;
        }

        button:disabled {
            background: #424242;
            color: #757575;
            cursor: not-allowed;
            transform: none;
        }

        #log {
            font-family: "JetBrains Mono", monospace;
            font-size: 10px;
            color: #757575;
            margin-top: 20px;
            white-space: pre-wrap;
            word-break: break-all;
            border-top: 1px solid #333;
            padding-top: 10px;
        }

        .status {
            font-size: 12px;
            margin-bottom: 10px;
            text-align: right;
            color: #757575;
        }

        .price {
            font-size: 24px;
            font-family: monospace;
            color: #fff;
            text-align: center;
            padding: 10px;
            background: #000;
            border-radius: 8px;
            margin-top: 5px;
        }
    </style>

    <script>
        // --- UTILS ---
        // Helper to request properties case-insensitively (cTrader sends PascalCase)
        function P(obj, key) {
            if (!obj) return undefined;
            // 1. Exact
            if (obj[key] !== undefined) return obj[key];
            // 2. PascalCase (key usually camelCase)
            const pascal = key.charAt(0).toUpperCase() + key.slice(1);
            if (obj[pascal] !== undefined) return obj[pascal];
            // 3. camelCase (if key is Pascal)
            const camel = key.charAt(0).toLowerCase() + key.slice(1);
            if (obj[camel] !== undefined) return obj[camel];

            return undefined;
        }

        // --- APP STATE ---
        const App = {
            accountId: null,
            balance: 0,
            currency: "USD",
            symbols: [],
            selectedSymbol: null,
            currentPrice: { bid: 0, ask: 0 },
            calculatedVol: 0
        };

        // --- TUNNEL LAYER ---
        const Tunnel = {
            queue: new Map(),
            listeners: [],

            send: (commandId, payload, callback) => {
                const bridge = window.EventBasedPluginJavaScriptBridge;
                if (!bridge) return;

                const innerMsgId = "req-" + commandId + "-" + Date.now() + Math.random().toString(36).substring(7);

                const innerMsg = {
                    payloadType: commandId,
                    clientMsgId: innerMsgId,
                    payload: payload || {}
                };

                if (callback) Tunnel.queue.set(innerMsgId, callback);

                const wrapper = {
                    payloadType: 2100,
                    clientMsgId: "wrap-" + innerMsgId,
                    payload: innerMsg
                };

                try {
                    bridge.handlePluginEvent(JSON.stringify(wrapper));
                } catch (e) {
                    UI.log("Send Err: " + e.message);
                }
            },

            onMessage: (wrapperMsg) => {
                let innerMsg = null;
                try {
                    if (wrapperMsg.payloadType === 2101 || wrapperMsg.payloadType === 2102) {
                        let raw = wrapperMsg.payload;
                        // Handle both object and string data
                        if (raw && raw.data && typeof raw.data === 'string') {
                            innerMsg = JSON.parse(raw.data);
                        } else if (raw && typeof raw === 'object') {
                            // Check if raw is the inner message (sometimes flattened?)
                            // If it has PayloadType inside...
                            if (raw.PayloadType || raw.payloadType) innerMsg = raw;
                            else if (raw.payload) innerMsg = raw; // Nested?
                        }
                    }
                } catch (e) { UI.log("Unwrap Err: " + e.message); }

                if (!innerMsg) {
                    if (wrapperMsg.payloadType === 2500) UI.log("SysErr: " + wrapperMsg.payload);
                    return;
                }

                // MsgID check (Pascal or camel)
                const msgId = P(innerMsg, "clientMsgId");
                const payload = P(innerMsg, "payload");

                if (msgId && Tunnel.queue.has(msgId)) {
                    const cb = Tunnel.queue.get(msgId);
                    Tunnel.queue.delete(msgId);
                    cb(payload);
                }

                Tunnel.listeners.forEach(l => l(innerMsg));
            },

            listen: (cb) => {
                Tunnel.listeners.push(cb);
            }
        };

        // --- LOGIC ---
        const Logic = {
            calcVol: () => {
                if (!App.selectedSymbol) return;
                if (!App.balance) return;

                const riskP = parseFloat(document.getElementById('in_risk').value) || 0;
                const slPips = parseFloat(document.getElementById('in_sl').value) || 0;

                if (riskP <= 0 || slPips <= 0) {
                    Logic.setResult(0, "Input Risk & SL");
                    return;
                }

                const riskAmt = App.balance * (riskP / 100);

                // Pip Value approx
                let pipValPerLot = 10;
                if (App.selectedSymbol.Name.includes("JPY") && App.currentPrice.bid > 0) {
                    pipValPerLot = 1000 / App.currentPrice.bid;
                }
                // For now, simple approximation. In real app, we need conversion rates.

                let lots = 0;
                if (pipValPerLot > 0) {
                    lots = riskAmt / (slPips * pipValPerLot);
                }

                // --- NORMALIZATION (CRITICAL FIX) ---
                // 1. Convert to Cents (Units * 100)
                // Assumed 1 Lot = 100,000 units = 10,000,000 cents
                let rawCents = lots * 100000 * 100;

                // 2. Get Step Volume (from Symbol Details)
                // Default 1000 cents (0.01 lot) if missing
                const stepVol = App.selectedSymbol.StepVolume || 1000;
                const minVol = App.selectedSymbol.MinVolume || 1000;

                // 3. Round to nearest Step
                let normCents = Math.floor(rawCents / stepVol) * stepVol;

                // 4. Check Min
                if (normCents < minVol) normCents = 0; // Or minVol? Better 0 to warn.

                App.calculatedVol = normCents;

                // Display Lots
                const dispLots = normCents / (100000 * 100);
                Logic.setResult(dispLots.toFixed(2), `Risk: $${riskAmt.toFixed(2)}`);
            },

            setResult: (lots, msg) => {
                document.getElementById('out_lots').textContent = lots + " Lots";
                document.getElementById('out_msg').textContent = msg;

                const btn = document.getElementById('btn_trade');
                btn.disabled = (parseFloat(lots) <= 0);
            },

            placeOrder: () => {
                if (App.calculatedVol <= 0) return;

                UI.log(`Sending Order: ${App.calculatedVol} cents...`);

                const cmd = {
                    symbolId: App.selectedSymbol.Id,
                    orderType: 1, // MARKET
                    tradeSide: 1, // BUY
                    volume: App.calculatedVol
                };

                Tunnel.send(143, cmd, (res) => { // ProtoCreateNewOrderReq
                    const errCode = P(res, "errorCode");
                    if (errCode) alert("Order Failed: " + errCode);
                    else {
                        // Check if it was OrderErrorEvent
                        const pType = P(res, "payloadType"); // OR Type name
                        if (pType === "PROTO_ORDER_ERROR_EVENT") { // Name from logs
                            alert("Order Error: " + P(res, "errorCode"));
                        } else {
                            alert("Order Sent!");
                        }
                    }
                    UI.log("Order Res: " + JSON.stringify(res));
                });
            }
        };

        // --- UI LAYER ---
        const UI = {
            init: () => {
                window.addEventListener('message-from-host', (e) => {
                    const msg = e.data;
                    if (msg.payloadType === 2000) {
                        try {
                            window.EventBasedPluginJavaScriptBridge.handlePluginEvent(JSON.stringify({
                                payloadType: 2001,
                                clientMsgId: msg.clientMsgId,
                                payload: null
                            }));
                        } catch (e) { }

                        if (!App.ready) {
                            App.ready = true;
                            UI.start();
                        }
                    } else {
                        Tunnel.onMessage(msg);
                    }
                });

                document.getElementById('in_risk').oninput = Logic.calcVol;
                document.getElementById('in_sl').oninput = Logic.calcVol;
                document.getElementById('btn_trade').onclick = Logic.placeOrder;

                Tunnel.listen((msg) => {
                    // PascalCase check
                    const type = P(msg, "payloadType");

                    // 3: ProtoQuoteEvent
                    if (type === 3 || type === "PROTO_QUOTE_EVENT") {
                        const p = P(msg, "payload");
                        const symId = P(p, "symbolId");

                        if (App.selectedSymbol && symId === App.selectedSymbol.Id) {
                            const bid = P(p, "bid");
                            const ask = P(p, "ask");
                            if (bid) App.currentPrice.bid = bid / 100000;
                            if (ask) App.currentPrice.ask = ask / 100000;
                            UI.renderPrice();
                        }
                    }
                });
            },

            log: (txt) => {
                const el = document.getElementById('log');
                if (el) {
                    if (txt.length > 200) txt = txt.substring(0, 200) + "...";
                    el.textContent = `> ${txt}\n` + el.textContent.substring(0, 1000);
                }
            },

            start: () => {
                document.getElementById('status').textContent = "Connected";

                // 175: GetAccount
                Tunnel.send(175, {}, (res) => {
                    const trader = P(res, "trader");
                    if (trader) {
                        App.accountId = P(trader, "traderId") || P(trader, "login");
                        App.balance = (P(trader, "balance") || 0) / 100;
                        App.currency = P(res, "depositCurrency") || "USD";
                        UI.updateAccount();
                        UI.fetchSymbols();
                    } else {
                        UI.log("AccErr: " + JSON.stringify(res));
                    }
                });
            },

            updateAccount: () => {
                document.getElementById('acc_id').textContent = App.accountId;
                document.getElementById('acc_bal').textContent = App.balance.toFixed(2) + " " + App.currency;
            },

            fetchSymbols: () => {
                Tunnel.send(841, { includeArchivedSymbols: false }, (res) => {
                    const symbols = P(res, "symbol");
                    if (symbols) {
                        App.symbols = symbols; // Array
                        UI.renderSymbolSelector();
                    }
                });
            },

            renderSymbolSelector: () => {
                const sel = document.getElementById('sym_select');
                sel.innerHTML = "<option>Select Symbol</option>";
                // PascalCase 'Name'
                App.symbols.sort((a, b) => P(a, "name").localeCompare(P(b, "name")));

                App.symbols.forEach(s => {
                    const opt = document.createElement('option');
                    // PascalCase 'Id'
                    const id = P(s, "id");
                    const name = P(s, "name");
                    opt.value = id;
                    opt.text = name;

                    // Normalize object for App use
                    s.Id = id;
                    s.Name = name;

                    sel.add(opt);
                });

                sel.onchange = () => {
                    const id = parseInt(sel.value);
                    const s = App.symbols.find(x => x.Id === id);
                    if (s) {
                        App.selectedSymbol = s;
                        UI.selectSymbol(s);
                    }
                };
            },

            selectSymbol: (s) => {
                UI.log("Selected: " + s.Name);
                document.getElementById('lbl_price').textContent = "---";

                Tunnel.send(601, { symbolId: [s.Id], subscribeToSpotTimestamp: true }, (res) => {
                    // Subscribed
                });

                // 163: Details
                Tunnel.send(163, { symbolId: [s.Id] }, (res) => {
                    const symbolList = P(res, "symbol");
                    if (symbolList && symbolList.length > 0) {
                        const det = symbolList[0];
                        // Merge details into App.selectedSymbol
                        App.selectedSymbol.StepVolume = P(det, "stepVolume");
                        App.selectedSymbol.MinVolume = P(det, "minVolume");
                        UI.log(`Details: Step=${App.selectedSymbol.StepVolume}`);
                        // Recalc to apply step
                        Logic.calcVol();
                    } else {
                        UI.log("DetErr: " + JSON.stringify(res));
                    }
                });
            },

            renderPrice: () => {
                const p = App.currentPrice;
                document.getElementById('lbl_price').textContent = `${p.bid} / ${p.ask}`;
                Logic.calcVol();
            }
        };

        window.onload = UI.init;
    </script>
</head>

<body>
    <div class="row">
        <h1>ALC v3.0</h1>
        <div id="status" class="status">Connecting...</div>
    </div>

    <!-- ACCOUNT -->
    <div class="card">
        <div class="row">
            <div>
                <span class="label">Balance</span>
                <div class="value" id="acc_bal">---</div>
            </div>
            <div style="text-align:right">
                <span class="label">Account</span>
                <div class="value" id="acc_id">---</div>
            </div>
        </div>
    </div>

    <!-- INPUTS -->
    <div class="card">
        <span class="label">Symbol</span>
        <select id="sym_select">
            <option>Loading...</option>
        </select>

        <div class="price" id="lbl_price">--- / ---</div>

        <div class="row" style="gap:10px; margin-top:15px;">
            <div style="flex:1">
                <span class="label">Risk %</span>
                <input type="number" id="in_risk" value="1.0" step="0.1">
            </div>
            <div style="flex:1">
                <span class="label">Stop Loss (Pips)</span>
                <input type="number" id="in_sl" value="20" step="1">
            </div>
        </div>
    </div>

    <!-- RESULT -->
    <div class="card" style="background: #263238;">
        <div class="row">
            <span class="label">Volume</span>
            <span class="label" id="out_msg">Input Params</span>
        </div>
        <div class="value" id="out_lots" style="font-size:24px; color:#4db6ac;">0.00 Lots</div>

        <button id="btn_trade" disabled style="margin-top:15px; padding:15px;">TRADE</button>
    </div>

    <div id="log"></div>
</body>

</html>